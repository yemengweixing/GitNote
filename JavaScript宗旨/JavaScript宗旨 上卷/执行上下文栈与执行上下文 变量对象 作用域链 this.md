---
title: 执行上下文栈与执行上下文(变量对象 作用域链 this)及作用域
tags: JavaScrip,作用域,执行上下文栈,执行上下文,变量对象,作用域链,this,可执行代码,
grammar_cjkRuby: true
---
# 可执行代码(executable code)
JavaScrip引擎执行代码是一段一段的 一段就是一个可执行代码(executable code)
可执行代码(executable code)的类型

三种，全局代码、函数代码、eval代码。

>JavaScript 代码执行遇到函数执行的时候，就会创建一个执行上下文(execution context)


# 执行上下文栈（Execution context stack，ECS）

JavaScript 引擎创建了执行上下文栈 来管理执行上下文（简单说**执行栈**就是**栈内存**）
比喻 执行栈是 [];
一
JavaScript 开始要解释执行代码，最先遇到	**全局代码**，所以最初会向执行上下文栈压入	**全局执行上下文**用 globalContext 表示，
程序结束之时，执行上下文栈才被清空，故序结束之前， 最底部永远有个 	**全局执行上下文**（初始化）
比喻 初始化时 执行栈是 [  globalContext  ];

ECStack = [
    globalContext
];

二
执行一个函数的时（执行非声明），会创建一个 **执行上下文**，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出（后入先出）
比喻 初始化时 执行栈是 [  globalContext ；  函数1 functionContext；  函数2  functionContext；	函数3		functionContext];
> 函数执行上下文 环境，跟 全局上下文 差不多，不过 函数执行上下文 中会多出this arguments和函数的参数。参数和arguments好理解，这里的this咱们需要专门讲解。


>变量提升 函数提升
在一段 JS 脚本执行之前，要先解析代码（所以说 JS 是解释执行的脚本语言），解析的时候会先创建一个 全局执行上下文 环境，
先把代码中即将执行的（内部函数的不算，因为你不知道函数何时执行）变量、函数声明都拿出来。变量先暂时赋值为undefined，函数则先声明好可使用（「全文解析」提升先存入了执行上下文）。这一步做完了，然后再开始正式执行程序。再次强调，这是在代码执行之前才开始的工作。

总结一下：

范围：一段js 文件或者一个函数
全局上下文：变量定义，函数声明
函数上下文：变量定义，函数声明，this，arguments


# 执行上下文(execution context)  即执行代码的环境（执行之前创建）
可分为 全局执行上下文 和 函数执行上下文
每个执行上下文，都有三个重要属性：

变量对象(Variable object，VO)
作用域链(Scope chain)
this



# 变量对象(Variable object，VO)
变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的**变量和函数声明**
变量对象可区分为：全局上下文下的变量对象和函数上下文下的变量对象。


# 全局上下文的变量对象 
 即**全局对象**(Window 对象) 
 是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。
 全局作用域中 可通过this引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询
>全局对象是由 Object 构造函数实例化的一个对象 console.log(this instanceof Object);

 # 函数上下文的变量对象
函数上下文中，用活动对象(activation object, AO)来表示变量对象
活动对象==变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问
>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象

**执行上下文的代码会分成两个步骤进行处理：分析	执行（即进入执行上下文和代码执行）**
全局上下文的变量对象初始化是全局对象
**一 当进入执行上下文 （还没有执行代码）**

变量对象会包括：

1函数的所有形参 (如果是函数上下文)
由名称和对应值组成的一个变量对象的属性被创建
没有实参，属性值设为 undefined

2函数声明
由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
如果变量对象已经存在相同名称的属性，则完全替换这个属性

3变量声明
由名称和对应值（undefined）组成一个变量对象的属性被创建；
如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
>变量提升 变量声明为undefined

**二 代码执行** 
在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值
>变量提升的声明变量 从undefined赋值为对应的值

1函数上下文的变量对象初始化只包括 Arguments 对象
>arguments对象是所有（非箭头）函数中都可用的局部变量。类似于Array，但除了length属性和索引元素之外没有任何Array属性。包含传递给函数的每个参数，第一个参数在索引0处。arguments.callee指向当前执行的函数

2在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值

3在代码执行阶段，会再次修改变量对象的属性值









# 作用域链
查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链


函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 **[[scope]] 就是所有父变量对象的层级链**但是注意：[[scope]] 并不代表完整的作用域链！

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。(下方第五步)

1 一个函数创建时
 函数被创建，保存作用域链到 内部属性[[scope]]
function.[[scope]] = [
    globalContext.VO                     //全局对象
];

2.执行函数，创建  函数执行上下文，函数执行上下文被压入执行上下文栈

3. 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性（到执行上下文）创建作用域链
//函数执行上下文
函数Context = {
    Scope: 函数.[[scope]],
}

4.用 arguments 创建活动对象（AO），随后初始化活动对象，加入形参、函数声明、变量声明

functionContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    }，
    Scope: checkscope.[[scope]],
}

5.将活动对象压入 函数 作用域链顶端

functionContext = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: undefined
    },
    Scope: [AO, [[Scope]]]
}
6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值

函数Context = {
    AO: {
        arguments: {
            length: 0
        },
        scope2: 'local scope'
    },
    Scope: [AO, [[Scope]]]
}
7.函数执行完毕，函数上下文从执行上下文栈中弹出

ECStack = [
    globalContext
];


javascript中作用域链是函数 变量 常量等标识符的查找机制，而原型链是对象属性的查找机制
有两种方法可以将作用域进行延长:
①、try-catch 语句的catch块
②、with 语句


 # this
![enter description here](./images/1553658862108.png)

//看被谁调用

1作为普通函数执行(全局对象的属性）
function foo() {
	console.log(this.a)
}
var a = 1
foo()
// 被全局对象调用      windos.foo()

2作为对象属性执行（非全局对象）
var obj = {
	a: 2,
	foo: foo
}
// 被全局对象下的对象调用  windos.obj.foo()
// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况

3 作为构造函数执行，构造函数中
// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向
var c = new foo()
c.a = 3
console.log(c.a)

4利用 call，apply，bind 改变 this，这个优先级仅次于 new


5
箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this


